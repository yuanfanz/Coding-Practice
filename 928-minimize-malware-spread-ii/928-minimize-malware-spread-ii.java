class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        // first, get a set that contains all initial infected nodes
        Set<Integer> set = new HashSet<>();
        for (int i : initial) {
            set.add(i);
        }
        Map<Integer, List<Integer>> map = buildGraph(graph);
        Map<Integer, List<Integer>> canBeInfectedBy = new HashMap<>();
        // do BFS for all initial infected nodes
        // stop BFS when encounter other initial infected nodes
        for (int i = 0; i < initial.length; ++i) {
            Queue<Integer> queue = new LinkedList<>();
            int curInitial = initial[i];
            queue.offer(curInitial);
            boolean[] visited = new boolean[n];
            while (queue.size() > 0) {
                int cur = queue.poll();
                if (visited[cur]) continue;
                visited[cur] = true;
                // if (initial[i] == cur) continue;
                List<Integer> infectList = canBeInfectedBy.getOrDefault(cur, new ArrayList<>());
                infectList.add(curInitial);
                List<Integer> list = map.getOrDefault(cur, new ArrayList<>());
                for (int next : list) {
                    if (set.contains(next)) continue;
                    queue.offer(next);
                }
                if (initial[i] == cur) continue;
                canBeInfectedBy.put(cur, infectList);
            }
        }
        // System.out.println(canBeInfectedBy.size());
        Map<Integer, Integer> indexMap = new HashMap<>();
        for (int i = 0; i < initial.length; ++i) {
            indexMap.put(initial[i], i);
        }
        int[] numberInfected = new int[n];
        for (int key : canBeInfectedBy.keySet()) {
            // System.out.print(key + " ");
            // System.out.println(canBeInfectedBy.get(key).size());
            if (canBeInfectedBy.get(key).size() == 1) {
                int curInitial = canBeInfectedBy.get(key).get(0);
                numberInfected[curInitial]++;
            }
        }
        Arrays.sort(initial);
        int maxSize = 0;
        int res = initial[0];
        for (int i = 0; i < n; ++i) {
            // System.out.print(i + " ");
            // System.out.println(numberInfected[i]);
            if (numberInfected[i] > maxSize) {
                maxSize = numberInfected[i];
                res = i;
            }
        }
        return res;
    }
    
    private Map<Integer, List<Integer>> buildGraph(int[][] graph) {
        Map<Integer, List<Integer>> map = new HashMap<>();
        
        for (int i = 0; i < graph.length; ++i) {
            for (int j = 0; j < graph[i].length; ++j) {
                if (i == j || graph[i][j] == 0) continue;
                List<Integer> list1 = map.getOrDefault(i, new ArrayList<>());
                List<Integer> list2 = map.getOrDefault(j, new ArrayList<>());
                list1.add(j);
                list2.add(i);
                map.put(i, list1);
                map.put(j, list2);
            }
        }
        return map;
    }
}































